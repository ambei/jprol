/* * Copyright 2014 Igor Maznitsa (http://www.igormaznitsa.com). * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *//* * Copyright (C) 2014 Igor Maznitsa (http://www.igormaznitsa.com) * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program.  If not, see <http://www.gnu.org/licenses/>. */package com.igormaznitsa.prol.data;import com.igormaznitsa.prol.exceptions.ProlCriticalError;import com.igormaznitsa.prol.utils.Utils;import java.util.HashMap;import java.util.Map;import static com.igormaznitsa.prol.data.TermType.ATOM;import static com.igormaznitsa.prol.data.TermType.VAR;public class Term {  private final String termText;  public Term(final String termText) {    this.termText = termText;  }  public int getPriority() {    return 0;  }  public String getText() {    return termText;  }  public TermType getTermType() {    return ATOM;  }  public boolean equWithoutSet(Term term) {    if (this == term) {      return true;    }    if (term.getTermType() == VAR) {      term = ((Var) term).getValue();    }    if (term == null) {      return true;    }    if (term.getTermType() == ATOM) {      return getText().equals(term.getText());    }    return false;  }  public boolean checkVariables() {    return true;  }  public void fillVarables(final Map<String, Var> table) {  }  public String getSourceLikeRepresentation() {    return '\'' + Utils.encodeTextSourceLike(getText()) + '\'';  }  @Override  public String toString() {    return getSourceLikeRepresentation();  }  @Override  public int hashCode() {    if (termText == null) {      return super.hashCode();    } else {      return termText.hashCode();    }  }  @Override  public boolean equals(final Object obj) {    if (obj == null) {      return false;    }    if (this == obj) {      return true;    }    final Class<?> objclass = obj.getClass();    if (objclass == TermInteger.class || obj.getClass() == Term.class) {      final Term other = (Term) obj;      if (hashCode() != other.hashCode()) {        return false;      }      return this.termText.equals(other.termText);    } else {      return false;    }  }  public String getSignature() {    return getText();  }  public String forWrite() {    return getText();  }  public boolean Equ(final Term otherTerm) {    if (this == otherTerm) {      return true;    }    boolean result = false;    switch (otherTerm.getTermType()) {      case ATOM: {        result = getText().equals(otherTerm.getText());      }      break;      case STRUCT: {        final TermStruct struct = (TermStruct) otherTerm;        if (struct.getArity() == 0) {          result = struct.getFunctor().getText().equals(termText);        }      }      break;      case VAR: {        final Var var = (Var) otherTerm;        final Term value = var.getValue();        if (value == null) {          result = ((Var) otherTerm).setValue(this);        } else {          result = Equ(value);        }      }      break;    }    return result;  }  public TermList asCharList() {    final String text = getText();    final int len = text.length();    if (len == 0) {      return TermList.NULLLIST;    }    final StringBuilder buff = new StringBuilder(1);    TermList resultList = null;    TermList curList = null;    for (int li = 0; li < len; li++) {      buff.append(text.charAt(li));      final Term newAtom = new Term(buff.toString());      buff.setLength(0);      if (li == 0) {        resultList = new TermList(newAtom);        curList = resultList;      } else {        curList = TermList.appendItem(curList, newAtom);      }    }    return resultList;  }  public TermList asCharCodeList() {    if (termText == null) {      return TermList.NULLLIST;    }    final int len = termText.length();    if (len == 0) {      return TermList.NULLLIST;    }    TermList resultList = null;    TermList curList = null;    for (int li = 0; li < len; li++) {      final Term newAtom = new TermInteger(termText.charAt(li));      if (li == 0) {        resultList = new TermList(newAtom);        curList = resultList;      } else {        curList = TermList.appendItem(curList, newAtom);      }    }    return resultList;  }  public int termComparsion(Term atom) {    if (this == atom) {      return 0;    }    if (atom.getTermType() == VAR && !((Var) atom).isUndefined()) {      atom = ((Var) atom).getValue();    }    switch (atom.getTermType()) {      case ATOM: {        if (atom instanceof NumericTerm) {          return 1;        }        return termText.compareTo(atom.termText);      }      case VAR: {        return 1;      }      case OPERATOR: {        return termText.compareTo(atom.termText);      }      default:        return -1;    }  }  public boolean hasAnyDifference(final Term comparedTerm) {    if (comparedTerm.getTermType() != ATOM || comparedTerm instanceof NumericTerm) {      return true;    }    return !termText.equals(comparedTerm.termText);  }  public int getTextLength() {    int result = 0;    if (termText != null) {      result = termText.length();    }    return result;  }  public boolean hasVariableWithName(final String name) {    return false;  }  public Term makeClone() {    final Term termToBeClone = this;    Term result = null;    switch (termToBeClone.getTermType()) {      case ATOM:      case OPERATOR: {        result = termToBeClone;      }      break;      case STRUCT: {        if (((TermStruct) termToBeClone).getArity() == 0) {          result = termToBeClone;        }      }      break;      case LIST: {        if (termToBeClone == TermList.NULLLIST) {          result = termToBeClone;        } else {          final Map<Integer, Var> varHashMap = new HashMap<>();          result = termToBeClone.makeClone(varHashMap);        }      }      break;      case VAR: {        final Var termAsVar = (Var) termToBeClone;        final Term value = ((Var) termToBeClone).getThisValue();        result = termAsVar.isAnonymous() ? new Var() : new Var(termAsVar.getText());        if (value != null) {          boolean makeClone = true;          switch (value.getTermType()) {            case ATOM:            case OPERATOR: {              ((Var) result).setThisValue(value);              makeClone = false;            }            break;            case STRUCT: {              if (((TermStruct) value).getArity() == 0) {                ((Var) result).setThisValue(value);                makeClone = false;              }            }            break;            case LIST: {              if (((TermList) value).isNullList()) {                ((Var) result).setThisValue(TermList.NULLLIST);                makeClone = false;              }            }            break;          }          if (makeClone) {            final Map<Integer, Var> varHashMap = new HashMap<>();            varHashMap.put(((Var) termToBeClone).getVarUID(), (Var) result);            ((Var) result).setThisValue(value.makeClone(varHashMap));          }        }      }      break;      default:        throw new ProlCriticalError("Attempt to clone a system non-clonable term");    }    if (result == null) {      final Map<Integer, Var> varHashMap = new HashMap<>();      result = termToBeClone.makeClone(varHashMap);    }    return result;  }  private Term makeClone(final Map<Integer, Var> variableSet) {    final Term term = this;    Term result;    switch (term.getTermType()) {      case OPERATOR:      case ATOM: {        result = term;      }      break;      case LIST: {        final TermList source = (TermList) term;        if (source == TermList.NULLLIST) {          result = source;        } else {          final Term head = source.getHead().makeClone(variableSet);          final Term tail = source.getTail().makeClone(variableSet);          result = new TermList(head, tail);        }      }      break;      case VAR: {        final Var var = (Var) term;        final Term val = var.getThisValue();        if (val == null) {          final String varName = var.getText();          final int varId = var.getVarUID();          Var newVar = variableSet.get(varId);          if (newVar == null) {            newVar = var.isAnonymous() ? new Var() : new Var(varName);            variableSet.put(varId, newVar);            final Term thisVal = var.getThisValue();            if (thisVal != null) {              newVar.setThisValue(thisVal.makeClone(variableSet));            }          }          result = newVar;        } else {          result = val.makeClone(variableSet);        }      }      break;      case STRUCT: {        final TermStruct source = (TermStruct) term;        if (source.getArity() == 0) {          result = term;        } else {          final Term[] elements = source.getElementsAsArray();          final int arity = elements.length;          final Term[] destElements = new Term[arity];          for (int li = 0; li < arity; li++) {            final Term element = elements[li];            destElements[li] = element.makeClone(variableSet);          }          result = new TermStruct(source.getFunctor(), destElements, source.getPredicateProcessor());        }      }      break;      default:        throw new ProlCriticalError("Attemption to clone a system non-clonable term");    }    return result;  }}